## ututorial

docker run --name repo alpine/git clone https://github.com/docker/getting-started.git

docker cp repo:/git/getting-started/ .

cd getting-started

docker build -t docker101tutorial .

docker run -d -p 80:80 --name docker-tutorial docker101tutorial

docker tag docker101tutorial {username}/docker101tutorial

docker push {username}/docker101tutorial

``` bash
vim /etc/docker/daemon.json
{
    "registry-mirrors":["https://docker.mirrors.ustc.edu.cn"]
}
systemctl daemon-reload 
systemctl restart docker
```







## 基本命令

```bash
docker exec <container-id> cat /data.txt
```

## 创建image

* 编写Dockerfile

* 执行build命令

  ``` bash
  docker build -t getting-start-pan .
  docker image ls #可以查询到getting-start-pan
  docker run -dp 3000:3000 getting-start-pan
  docker tag getting-start-pan pzh2467908/getting-started
  docker push pzh2467908/getting-started
  ```



## 共享文件

1. ```
   docker volume create todo-db
   docker run -dp 3000:3000 -v todo-db:/etc/todos getting-started
   docker volume inspect todo-db #查看volume存储位置
   ```

## container间通信

```bash
docker network create todo-app
docker run -d \
    --network todo-app --network-alias mysql \
    -v todo-mysql-data:/var/lib/mysql \  #使用volume:todo-mysql-data,并挂载到/var/lib/mysql；类似docker volume create
    -e MYSQL_ROOT_PASSWORD=secret \
    -e MYSQL_DATABASE=todos \
    mysql:5.7
```

* 如何让别的container找到mysql?使用 [nicolaka/netshoot](https://github.com/nicolaka/netshoot) container,

  * 创建nicolaka/netshoot container，并连接到mysql同一个network

  * 进入到container中，并使用DNS服务工具dig，找到mysql host的IP

    ``` bash
    docker run -it --network todo-app nicolaka/netshoot
    ```

``` bash
docker run -dp 3000:3000 \
  -w /app -v "$(pwd):/app" \ #-w:workdir, -v:volume
  --network todo-app \
  -e MYSQL_HOST=mysql \
  -e MYSQL_USER=root \
  -e MYSQL_PASSWORD=secret \
  -e MYSQL_DB=todos \
  node:12-alpine \
  sh -c "yarn install && yarn run dev"
  
  docker log <id> #查看app连接mysql过程
  docker exec -it <mysql-container-id> mysql -p todos
```



## docker compose

``` yaml
version: "3.7"

services:
  app:
    image: node:12-alpine
    command: sh -c "yarn install && yarn run dev"
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: root
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment: 
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
```

``` bash
docker-compose up -d
docker-compose logs -f
docker-compose down (--volumes)
```

```bash
sudo docker run --name myjenkins -p 8080:8080 -p 50000:50000 -P -v jenkins_data:/var/jenkins_home jenkins/jenkins:lts
sudo docker run -d -P -v /mnt/disk3/openbmc:/home/docker/openbmc --name openbmc bradchou/ubuntu:openbmc #docker:docker
sudo docker run -d -P -v /mnt/disk2/openbmc:/home/docker/openbmc --net host --hostname ft625 --name openbmc bradchou/ubuntu:openbmc
docker run \
  -u root \
  --rm \  # 关闭时自动删此容器
  -d \  # 在后台运行容器（即“分离”模式）并输出容器ID，否则在终端窗口中输出正在运行的此容器的Docker日志
  -p 8080:8080 \  # 映射主机端口（第一个数字8080）和容器端口（后一个数字8080），用于HTTP访问
  -p 50000:50000 \  # 映射主机端口（第一个数字50000）和容器端口（后一个数字50000），用于连接Agent
  -v jenkins-data:/var/jenkins_home \  # 将Jenkins的Home目录映射到本地
  -v /var/run/docker.sock:/var/run/docker.sock \  # 允许容器与Docker守护进程通信
  jenkins/jenkins:lts
 
sudo docker exec -it myjenkins bash
sudo docker logs myjenkins
sudo docker inspect myjenkins
```

``` bash
docker run -it --rm --log-driver none jess/telnet towel.blinkenlights.nl
```

## 网络配置

* `--net=bridge`,连接到默认网桥

  * 使用linux net bridge, 默认为docker0
  * 使用veth pair，一头在container，一头在docker0上
  * docker container不具有公有IP，因为 host IP与veth pair IP不在同一个网段内
  * 采用NAT模式，绑定container listen port 到 host port ，使得宿主机以外的世界可以主动将网络报文发送到容器内部
  * container拥有独立隔离的 net stack, container和host通过NAT建立通信

* `--net=host`,使用主机的网络，拥有host接口访问权限，如果使用参数`--privileged=true`,容器会被允许直接配置主机网络堆栈

  * docker container ip = host ip
  * 没有隔离的network namespace
  * host模式可以和其他模式并存

* `--net=container:NAME\_OR\_ID`, 新容器会被置到一个已存在的容器网络堆栈中，共享ip地址和端口资源，两者进程可通过lo还回通信

* `--net=none`, 将新容器放到隔离的网络栈中，不进行网络配置，用户可以自行配置

  ``` bash
  #https://www.cnblogs.com/hukey/p/6569132.html
  sudo ip link add name veth0 type veth peer name veth1 #创建网络端口对
  sudo ip netns add 4943 #创建 net namespace
  sudo brctl show #查看当前网桥设备
  sudo brctl addif docker0 veth0   #将veth0加入docker0这个网桥 
  sudo ip link set up veth0 #up端口
  sudo ip link set veth1 netns 4943  #增加端口到namespace 
  #sudo ip netns exec 4943 ifconfig -a #查看namespace中网卡设备
  #sudo ip netns list #查看namespace
  sudo ip netns exec 4943 ifconfig lo up 
  ```

  

## FAQ

``` BASH
Creating volume "gitlab-config" with default driver
Creating volume "gitlab-logs" with default driver
Creating volume "gitlab-data" with default driver
Pulling gitlab (gitlab/gitlab-ce:)...
ERROR: Get https://registry-1.docker.io/v2/: net/http: TLS handshake timeout
```

```bash
#解决
sudo vi /etc/docker/daemon.json
#{
#    "registry-mirrors":["https://docker.mirrors.ustc.edu.cn"]
#}
sudo systemctl restart docker
# or
docker pull docker.mirrors.ustc.edu.cn/library/gitlab/gitlab-ce
```

qemu-system-arm -m 256 -M romulus-bmc -nographic -drive file=/home/openbmc/obmc-phosphor-image-ft2500-20201126105432.static.mtd,format=raw,if=mtd -net nic -net user,hostfwd=:127.0.0.1:3222-:22,hostfwd=:127.0.0.1:3443-:443,hostname=qemu

sudo docker run --name ibmbmc --net=host  -v /mnt/disk3/openbmc/:/home/openbmc jess/openbmc

qemu-system-arm -m 256 -M romulus-bmc -nographic -drive file=/opt/image/obmc-phosphor-image-ft2500.static.mtd,format=raw,if=mtd -net nic -net user,hostfwd=:127.0.0.1:3222-:22,hostfwd=:127.0.0.1:3443-:443,hostname=qemu
