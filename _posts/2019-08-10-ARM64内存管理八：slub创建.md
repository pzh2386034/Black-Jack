---
title: ARM64内存管理八：slub机制
date: 2019-08-10
categories:
- linux-memory
tags:
- mm,slab
---


## 前沿

### 往篇回顾

在上一篇中，我们正式进入slub系统的学习，主要分析了slub系统初始化的过程，关键函数是`start_kernel()->mm_init()->kmem_cache_init()`，在该函数中依次完成了以下动作：

* 完成slub管理框架内存申请，即两个关键slub："kmem_cache", "kmem_cache_node";

* 使用`bootstrap`函数刷新各个内存node节点中struct page->slab_cache指针；

* 在`create_kmalloc_caches`中，完成size_index和kmem_caches映射，并使用`create_kmalloc_cache`初始化kmem_caches结构体数组；


### 本篇主要内容

>本篇主要分析slub分配器申请过程


## 代码分析

### kmem_cache_create

``` c++
/*
 * kmem_cache_create - Create a cache.
 * @name: 用于/proc/slabinfo文件中显示此高速缓冲的字符串
 * @size: 要创建的slub中每个对象的大小
 * @align: 对象对齐偏移量
 * @flags: 对应slab的标志
 * @ctor: 构建对象构造函数
 * 
 * 函数成功时返回指向cache的指针，失败时返回NULL.
 * 中断中不允许调用，但是调用过程中可以被中断.
 * 当针对cache的新的页框分配成功时运行ctor构造函数.
 *
 */
struct kmem_cache *
kmem_cache_create(const char *name, size_t size, size_t align,
		  unsigned long flags, void (*ctor)(void *))
{
	struct kmem_cache *s;
	const char *cache_name;
	int err;

	get_online_cpus();
	get_online_mems();
	memcg_get_cache_ids();

	mutex_lock(&slab_mutex);

	err = kmem_cache_sanity_check(name, size);
	if (err) {
		s = NULL;	/* suppress uninit var warning */
		goto out_unlock;
	}

	flags &= CACHE_CREATE_MASK;
	/* 
	 * 调用find_mergeable查找是否有能复用的kmem_cache,全局变量slab_unmerge被置位时不允许复用：
	 * list_for_each_entry_reverse会遍历slab_cache全局链表，检查以下几项
	 * 1. 两者的size要足够接近，差距小于sizeof(void *)；且现有的要大些，当然新创建的size要经过L1对齐
	 * 2. flags标志
	 * 3. 两个kemem_cache对齐要一致
	 *
	 * 如果找到合适的复用kmem_cache，则kmem_cache->refcount++，refcount反映kmem_cache的复用次数
     * 最后调用sysfs_slab_alias在sysfs中添加别名
	 */
	s = __kmem_cache_alias(name, size, align, flags, ctor);
	if (s)
		goto out_unlock;
	/* 
	 * 使用GFP_KERNEL模式申请内存，将形参name的内容copy到这段新申请的内存中
	 * 如果name本身在rdata数据区，则不复制
	 */
	cache_name = kstrdup_const(name, GFP_KERNEL);
	if (!cache_name) {
		err = -ENOMEM;
		goto out_unlock;
	}
	/* 
	 * 将主要参数配置到slab描述符，然后将得到的描述符加入slab_caches全局链表中，其中：
	 * 1. kmem_cache_zalloc：使用GFP_KERNEL, 为kmem_cache结构体申请内存
     * 2. 初始化kmem_cache结构体数据
	 * 3. __kmem_cache_create： 创建slub描述符的核心：对齐操作、计算需要的页面、对象数目、对slab着色等，后面会进一步分析
	 * 
	 */
	s = do_kmem_cache_create(cache_name, size, size,
				 calculate_alignment(flags, align, size),
				 flags, ctor, NULL, NULL);
	if (IS_ERR(s)) {
		err = PTR_ERR(s);
		kfree_const(cache_name);
	}

out_unlock:
	mutex_unlock(&slab_mutex);

	memcg_put_cache_ids();
	put_online_mems();
	put_online_cpus();

	if (err) {
		if (flags & SLAB_PANIC)
			panic("kmem_cache_create: Failed to create slab '%s'. Error %d\n",
				name, err);
		else {
			printk(KERN_WARNING "kmem_cache_create(%s) failed with error %d",
				name, err);
			dump_stack();
		}
		return NULL;
	}
	return s;
}
```

### __kmem_cache_create

``` c++
/*
 * 初始化slub结构
 */
int __kmem_cache_create(struct kmem_cache *s, unsigned long flags)
{
	int err;

	err = kmem_cache_open(s, flags);
	if (err)
		return err;

	/* Mutex is not taken during early boot */
	if (slab_state <= UP)
		return 0;

	memcg_propagate_slab_attrs(s);
    /* 将kmem_cache添加到sysfs */
	err = sysfs_slab_add(s);
	if (err)
    /*如果出错则销毁slub*/
		kmem_cache_close(s);

	return err;
}
```

### kmem_cache_open

``` c++
static int kmem_cache_open(struct kmem_cache *s, unsigned long flags)
{
/*根据slub_debug标志看是否要更新flags*/
	s->flags = kmem_cache_flags(s->size, flags, s->name, s->ctor);
	s->reserved = 0;

	if (need_reserve_slab_rcu && (s->flags & SLAB_DESTROY_BY_RCU))
		s->reserved = sizeof(struct rcu_head);

	if (!calculate_sizes(s, -1))
		goto error;
	if (disable_higher_order_debug) {
		/*
		 * Disable debugging flags that store metadata if the min slab
		 * order increased.
		 */
		if (get_order(s->size) > get_order(s->object_size)) {
			s->flags &= ~DEBUG_METADATA_FLAGS;
			s->offset = 0;
			if (!calculate_sizes(s, -1))
				goto error;
		}
	}

#if defined(CONFIG_HAVE_CMPXCHG_DOUBLE) && \
    defined(CONFIG_HAVE_ALIGNED_STRUCT_PAGE)
	if (system_has_cmpxchg_double() && (s->flags & SLAB_DEBUG_FLAGS) == 0)
		/* Enable fast mode */
		s->flags |= __CMPXCHG_DOUBLE;
#endif

	/*
	 * The larger the object size is, the more pages we want on the partial
	 * list to avoid pounding the page allocator excessively.
	 */
	set_min_partial(s, ilog2(s->size) / 2);

	/*
	 * cpu_partial determined the maximum number of objects kept in the
	 * per cpu partial lists of a processor.
	 *
	 * Per cpu partial lists mainly contain slabs that just have one
	 * object freed. If they are used for allocation then they can be
	 * filled up again with minimal effort. The slab will never hit the
	 * per node partial lists and therefore no locking will be required.
	 *
	 * This setting also determines
	 *
	 * A) The number of objects from per cpu partial slabs dumped to the
	 *    per node list when we reach the limit.
	 * B) The number of objects in cpu partial slabs to extract from the
	 *    per node list when we run out of per cpu objects. We only fetch
	 *    50% to keep some capacity around for frees.
	 */
	if (!kmem_cache_has_cpu_partial(s))
		s->cpu_partial = 0;
	else if (s->size >= PAGE_SIZE)
		s->cpu_partial = 2;
	else if (s->size >= 1024)
		s->cpu_partial = 6;
	else if (s->size >= 256)
		s->cpu_partial = 13;
	else
		s->cpu_partial = 30;

#ifdef CONFIG_NUMA
	s->remote_node_defrag_ratio = 1000;
#endif
	if (!init_kmem_cache_nodes(s))
		goto error;

	if (alloc_kmem_cache_cpus(s))
		return 0;

	free_kmem_cache_nodes(s);
error:
	if (flags & SLAB_PANIC)
		panic("Cannot create slab %s size=%lu realsize=%u "
			"order=%u offset=%u flags=%lx\n",
			s->name, (unsigned long)s->size, s->size,
			oo_order(s->oo), s->offset, flags);
	return -EINVAL;
}
```

## 附录

### kmem_cache结构体

``` c++
/*
 * Slab cache management.
 */
struct kmem_cache {
	struct kmem_cache_cpu __percpu *cpu_slab;
	/* Used for retriving partial slabs etc */
	unsigned long flags;
	unsigned long min_partial;
	int size;		/* The size of an object including meta data */
	int object_size;	/* The size of an object without meta data */
	int offset;		/* Free pointer offset. */
	int cpu_partial;	/* Number of per cpu partial objects to keep around */
	struct kmem_cache_order_objects oo;

	/* Allocation and freeing of slabs */
	struct kmem_cache_order_objects max;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;	/* gfp flags to use on each alloc */
	int refcount;		/* Refcount for slab cache destroy */
	void (*ctor)(void *);
	int inuse;		/* Offset to metadata */
	int align;		/* Alignment */
	int reserved;		/* Reserved bytes at the end of slabs */
	const char *name;	/* Name (only for display!) */
	struct list_head list;	/* List of slab caches */
#ifdef CONFIG_SYSFS
	struct kobject kobj;	/* For sysfs */
#endif
#ifdef CONFIG_MEMCG_KMEM
	struct memcg_cache_params memcg_params;
	int max_attr_size; /* for propagation, maximum size of a stored attr */
#ifdef CONFIG_SYSFS
	struct kset *memcg_kset;
#endif
#endif

#ifdef CONFIG_NUMA
	/*
	 * Defragmentation by allocating from a remote node.
	 */
	int remote_node_defrag_ratio;
#endif
	struct kmem_cache_node *node[MAX_NUMNODES];
};
```

### kmem_cache_node结构体

``` c++
/* SLAB链表结构 */
struct kmem_cache_node {
    /* 锁 */
    spinlock_t list_lock;

/* SLAB用 */
#ifdef CONFIG_SLAB
    /* 只使用了部分对象的SLAB描述符的双向循环链表 */
    struct list_head slabs_partial;    /* partial list first, better asm code */
    /* 不包含空闲对象的SLAB描述符的双向循环链表 */
    struct list_head slabs_full;
    /* 只包含空闲对象的SLAB描述符的双向循环链表 */
    struct list_head slabs_free;
    /* 高速缓存中空闲对象个数(包括slabs_partial链表中和slabs_free链表中所有的空闲对象) */
    unsigned long free_objects;
    /* 高速缓存中空闲对象的上限 */
    unsigned int free_limit;
    /* 下一个被分配的SLAB使用的颜色 */
    unsigned int colour_next;    /* Per-node cache coloring */
    /* 指向这个结点上所有CPU共享的一个本地高速缓存 */
    struct array_cache *shared;    /* shared per node */
    struct alien_cache **alien;    /* on other nodes */
    /* 两次缓存收缩时的间隔，降低次数，提高性能 */
    unsigned long next_reap;    
    /* 0:收缩  1:获取一个对象 */
    int free_touched;        /* updated without locking */
#endif

/* SLUB用 */
#ifdef CONFIG_SLUB
    unsigned long nr_partial;
	/* 只使用了部分对象的SLAB描述符的双向循环链表 */
    struct list_head partial;
#ifdef CONFIG_SLUB_DEBUG
    atomic_long_t nr_slabs;
    atomic_long_t total_objects;
    struct list_head full;
#endif
#endif

};
```


## 参考资料

[slub debug](http://www.wowotech.net/memory_management/427.html)

[slub create代码解析](http://blog.chinaunix.net/uid-25940216-id-3202940.html)

[图解slub] (http://www.wowotech.net/memory_management/426.html)

[slub 分配器描述](https://www.cnblogs.com/tolimit/p/4566189.html#)
