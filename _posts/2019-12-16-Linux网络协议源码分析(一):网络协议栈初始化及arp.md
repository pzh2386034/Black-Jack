---
title: Linux网络协议源码分析(一):网络协议栈初始化及arp
date: 2019-12-17
categories:
- linux-net
tags:
- arp,net
---

## 前沿

### 网络协议源码系列

>在本系列中，将重点学习linux 1.2.13版本的网络协议源代码，可以同步学习[Linux 内核网络协议栈源码剖析](#参考资料)

* 为啥还要学习Linux老版本的代码呢？纯粹的心灵，纯粹的代码，才能有更纯粹的理解

* 为啥还要学习Linux老版本的代码呢？有指路仙人，避免迷失在code forest之中

#### 七层模型

>下三层是数据通信(通信子网)，上三层是数据处理(资源子网)；传输层是通信子网、资源子网的接口，承上启下

* 物理层：利用传输介质为数据链路层提供物理连接，实现比特流的透明传输

* 数据链路层：建立和管理节点间的链路；通过差错控制/流量控制，使有差错的物理线路变为无差错的数据链路；分为介质控制访问(MAC)/逻辑链路控制(LLC)

	1. MAC(medium access control)子层(IEEE802.3)：解决共享型网络中多用户对信道竞争问题，完成网络介质的访问控制
	
		媒介访问控制：确定链路两端是否使用同一种链路层协议；
		
		MAC地址：二层硬件地址
	
	2. LLC(Logical Link Control)子层(IEEE802.2)：建立和维护网络连接，执行差错校验，流量控制，链路控制
		
		LLC1：默认用来封装广播型链路；服务访问协议(SAP), 子网访问协议(SNAP-->arp)
		
		LLC2: 默认封装点对点链路

* 网络层：通过路由算法，为报文或分组通过通信子网选择最适当的路径；控制数据链路层与传输层之间的信息转发、建立、维持和终止网络的连接，IP、ICMP、RIP，该层要解决如下问题：

	1. 寻址：数据链路层使用物理地址(MAC地址)仅解决网络内部的寻址问题，不同子网间通信使用逻辑地址(IP地址) IP协议
	
	2. 交换：规定不同信息交换方式；线路交换、存储转发交换(报文交换，分组交换)
	
	3. 路由算法：源地址与目的地址间存在多条路径，由路由算法决定最佳路径 RIP(Routing information protocal)
	
	4. 连接服务：数据链路层控制网络相邻节点间流量；本层控制源节点到目的节点的流量，并防阻塞、差错检测 ICMP(Internet control message protocal)
	
* 传输层：向用户提供可靠的端到端差错、流量控制，保证报文传输正确,TCP、UDP、spx、NetBIOS/NetBEUI

	1. 从会话层中获取数据，必要是会对数据进行分割
	
	2. 确保将数据正确无误的传送到网络层
	
	3. 如果是"面向连接"服务，则在此层如果指定时间内未收到确认信息，数据将被重发
	
* 会话层：用户应用程序、网络之间的接口，向两个实体表示层提供建立和使用连接的方法；INET socket层(af_inet.c)

	1. 建立连接、保持连接、断开连接
	
* 表示层：对来自应用层的命令和数据进行解释，并按照一定的格式传送给会话层；BSD socket层(socket.c)

	1. 数据格式处理：协商和建立数据交换的格式，解决各应用程序之间在数据格式表示上的差异
	
	2. 数据的编码：处理字符集和数字的转换
	
	3. 压缩与解压缩；加密与解密
	
* 应用层：为用户提供服务、协议；ftp,telnet,email,dns,whois,smtp,http.....

### arp协议

* 在以太网上传输IP数据包时，以太设备并不能识别32位IP地址，而是以48位mac地址传输；因此IP数据包要封装成以太网帧

* arp协议是个下三层协议，用于发现局域网内设备；协议栈通过arp协议获取到网络上邻居主机的IP地址与MAC地址的对应关系，并保存在全局arp table中；

* arp table是个链式hash table

* 下面是在以太网中传输的arp报文结构

|目的MAC|源MAC|帧类型|硬件类型|上层协议类型|MAC地址长度|IP地址长度|op|smac|sip|tmac|tip|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
|6bytes|6bytes|2|2|2|1|1|6|4|6|4|
|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|

* 前3段为以太头；中5段位arp头；最后4段为arp数据

### linux网络设备初始化流程



### 本篇主要内容

* 网络协议栈初始化

* arp相关知识


## 代码分析

### 内核网络栈初始化

#### start_kernel

``` c++
/* 内核入口 */
asmlinkage void start_kernel(void)
{
	char * command_line;
/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */
	/* 平台初始化 */
	setup_arch(&command_line, &memory_start, &memory_end);
	/* 内存初始化 */
	memory_start = paging_init(memory_start,memory_end);
	trap_init();/* 陷阱初始化 */
	init_IRQ();/* 中断初始化 */
	sched_init();/* 进程调度初始化 */
	parse_options(command_line);/* uboot参数解析 */
	init_modules();
#ifdef CONFIG_PROFILE
	prof_buffer = (unsigned long *) memory_start;
	/* only text is profiled */
	prof_len = (unsigned long) &etext;
	prof_len >>= CONFIG_PROFILE_SHIFT;
	memory_start += prof_len * sizeof(unsigned long);
#endif
	memory_start = console_init(memory_start,memory_end);
	memory_start = bios32_init(memory_start,memory_end);
	memory_start = kmalloc_init(memory_start,memory_end);
	sti();
	calibrate_delay();
	memory_start = chr_dev_init(memory_start,memory_end);
	memory_start = blk_dev_init(memory_start,memory_end);
	sti();
#ifdef CONFIG_SCSI
	memory_start = scsi_dev_init(memory_start,memory_end);
#endif
#ifdef CONFIG_INET
	memory_start = net_dev_init(memory_start,memory_end);
#endif
	memory_start = inode_init(memory_start,memory_end);
	memory_start = file_table_init(memory_start,memory_end);
	memory_start = name_cache_init(memory_start,memory_end);
	mem_init(memory_start,memory_end);
	buffer_init();/* 缓冲区初始化 */
	time_init();/* 时间初始化 */
	sock_init();/* 网络初始化 */
#ifdef CONFIG_SYSVIPC
	ipc_init();
#endif
	sti();
	check_bugs();

	printk(linux_banner);

	if (!fork())		/* we count on this going ok */
		init();
/*
 * task[0] is meant to be used as an "idle" task: it may not sleep, but
 * it might do some general things like count free pages or it could be
 * used to implement a reasonable LRU algorithm for the paging routines:
 * anything that can be useful, but shouldn't take time from the real
 * processes.
 *
 * Right now task[0] just does a infinite idle loop.
 */
	for(;;)
		idle();
}
```

#### sock_init

``` c++
/* 网络初始化 */
void sock_init(void)
{
	int i;

	printk("Swansea University Computer Society NET3.019\n");

	/*
	 * 初始化协议族，全局结构体 pops ；默认支持配置16个协议族；
	 * 主要为协议族编号、协议操作方法
	 */
	 
	for (i = 0; i < NPROTO; ++i) pops[i] = NULL;

	/*
	 *	初始化kernel默认支持的协议，调用各个协议默认的初始化函数
	 * SNAP(子网络访问协议): IEEE802.2；数据链路层
	 * 802.2：高层协议与MAC子层的接口；数据链路层
	 * AX.25：？；数据链路层协议
	 * INET:
	 * IPX: 分组交换协议，提供分组寻址、选择路由的功能；网络层协议
	 * DDP：
	 */

	proto_init();

#ifdef CONFIG_NET
	/* 
	 * 往dev_base设备链表中加入配置的设备；所有配置的设备在space.c文件中；
	 * 初始化该链表中只有loopback_dev设备；通过next，一个接一个加入到dev_base中
	 * 对于NE设备，初始化函数均为ethif_probe->ne_probe->ne_probe1->init_etherdev->ether_setup
	 * 初始化过程中会注册网卡内存地址到 iolist中，并注册open、发送、接受、关闭、查询状态等函数
	 * 中断处理函数在open中会通过 request_irq 进行注册
	 * 有个中断号和device的映射表；中断产生后，根据该表格找到对应的device
	 */
	dev_init();
  
	/*
	 *	And the bottom half handler 
	 */
	bh_base[NET_BH].routine= net_bh;
	enable_bh(NET_BH);
#endif  
}
```

#### inet_proto_init

``` c++
/* 初始化INET协议族 */
void inet_proto_init(struct net_proto *pro)
{
	struct inet_protocol *p;
	int i;
	printk("Swansea University Computer Society TCP/IP for NET3.019\n");

	/* 在协议族全局结构体在中寻找空闲位置；并注册INET协议族方法结构体到其中*/
  	(void) sock_register(inet_proto_ops.family, &inet_proto_ops);

  	seq_offset = CURRENT_TIME*250;
	 
	for(i = 0; i < SOCK_ARRAY_SIZE; i++) 
	{
		tcp_prot.sock_array[i] = NULL;
		udp_prot.sock_array[i] = NULL;
		raw_prot.sock_array[i] = NULL;
  	}
	tcp_prot.inuse = 0;
	tcp_prot.highestinuse = 0;
	udp_prot.inuse = 0;
	udp_prot.highestinuse = 0;
	raw_prot.inuse = 0;
	raw_prot.highestinuse = 0;

	printk("IP Protocols: ");
	/* 初始化INET协议族中的子协议，ICMP,IGMP,TCP,UDP；并加入INET协议族结构体中 */
	for(p = inet_protocol_base; p != NULL;) 
	{
		struct inet_protocol *tmp = (struct inet_protocol *) p->next;
		inet_add_protocol(p);/* 将各个子协议加入到inet_protos中 */
		printk("%s%s",p->name,tmp?", ":"\n");
		p = tmp;
	}
	/* 初始化arp模块 */
	arp_init();
  	/* 初始化IP模块；类似arp，不再详细分析 */
	ip_init();
}

```

#### arp_init

``` c++
/* 初始化地址协议层：arp
 * 1. 将arp消息处理结构体挂到 packet_type队列上，指示kernel要接收处理arp报文，根据报文type=ETH_P_ARP(0X0806)
 * 2. 增加arp定时器，检查过期arp entry
 * 3. 将网络设备状态变更事件注册到内核通知链上
 */
void arp_init (void)
{
	/* 注册ARP报文到kernel接受数据包列表中 */
	arp_packet_type.type=htons(ETH_P_ARP);
	/* 将apr报文处理结构体挂到全局 packet_type 队列上，结构体中定义了arp packet handle函数 */
	dev_add_pack(&arp_packet_type);
	/* 增加arp定时器，定期检查arp表项是否过期；注册频率为60HZ. */
	add_timer(&arp_timer);
	/* arp事件注册到内核通知链中，通知链相关知识见参考文献 
	 * 内核关于网络的通知链有两条：
	 * 1. inetaddr_chain: 发送有关本地接口上的ipv4地址插入、删除、变更的通知信息
	 * 2. netdev_chain: 发送有关网络设备注册状态的通知信息
	 * 注册了一个网络设备状态变更处理函数 arp_device_event ，传入参数：
	 * 1. 事件类型(down,up,restart)
	 * 2. struct device 指针，指向发生变更的设备
	 * 只处理NOTIFY_DOWN事件，将设备表项T出arp table以及停尸表项定时器
	 */
	register_netdevice_notifier(&arp_dev_notifier);
}
```

#### arp_check_expire

``` c++
/* arp定时器回调函数：检测ARP表项是否过期，过期则清除
 * 如果ATF_PERM置位，则永久保存
 */
static void arp_check_expire(unsigned long dummy)
{
	int i;
	unsigned long now = jiffies;
	unsigned long flags;
	save_flags(flags);
	cli();

	for (i = 0; i < FULL_ARP_TABLE_SIZE; i++)
	{
		struct arp_table *entry;
		struct arp_table **pentry = &arp_tables[i];

		while ((entry = *pentry) != NULL)
		{
		/* 对每个表项上次使用时间标志进行检查，如果超过ARP_TIMEOUT，则表示已过期 */
			if ((now - entry->last_used) > ARP_TIMEOUT
				&& !(entry->flags & ATF_PERM))/* 置为ATF_PERM，则永久保存 */
			{
				*pentry = entry->next;	/* remove from list */
				del_timer(&entry->timer);	/* 停止该表项设置的定时器 */
				kfree_s(entry, sizeof(struct arp_table));
			}
			else
				pentry = &entry->next;	/* go to next entry */
		}
	}
	restore_flags(flags);

	/*
	 * Set the timer again.
	 * kernel tcp 协议栈重置的操作一般都是先清楚现有的，然后新建一个再插入到链表中
	 * 直接修改现有的，会造成内核状态不一致
	 */
	
	del_timer(&arp_timer);
	arp_timer.expires = ARP_CHECK_INTERVAL;
	add_timer(&arp_timer);
}
```

#### arp_rcv

``` c++
/*
 * 该函数为arp_packet_type结构体中注册的回调函数，结构体挂在kernel的 packet_type 网络报文处理队列上
 * 每当有arp数据包报文到达，会触发本函数
 * skb：arp数据包；dev：接受数据包的网络设备；pt：指向arp协议本身的 packet_type 
 */
int arp_rcv(struct sk_buff *skb, struct device *dev, struct packet_type *pt)
{

	struct arphdr *arp = (struct arphdr *)skb->h.raw;	/* arp首部. */
	unsigned char *arp_ptr= (unsigned char *)(arp+1);/* arp报文中的地址位置. */
	struct arp_table *entry;
	struct arp_table *proxy_entry;
	int addr_hint,hlen,htype;
	unsigned long hash;
	unsigned char ha[MAX_ADDR_LEN];	/* So we can enable ints again. */
	long sip,tip;
	unsigned char *sha,*tha;

	/* 健壮性check：地址检查、硬件类型检查、标志位检查 */  
	if (arp->ar_hln != dev->addr_len    || 
     		dev->type != ntohs(arp->ar_hrd) || 
		dev->flags & IFF_NOARP          ||
		arp->ar_pln != 4)
	{
		kfree_skb(skb, FREE_READ);
		return 0;
	}

	/* arp报文来源的硬件形态 */
  	switch(dev->type)
  	{
#ifdef CONFIG_AX25
		case ARPHRD_AX25://AX.25网络
			if(arp->ar_pro != htons(AX25_P_IP))
			{
				kfree_skb(skb, FREE_READ);
				return 0;
			}
			break;
#endif
		case ARPHRD_ETHER://以太网络
		case ARPHRD_ARCNET://令牌总线网络
			if(arp->ar_pro != htons(ETH_P_IP))
			{
				kfree_skb(skb, FREE_READ);
				return 0;
			}
			break;

		default:
			printk("ARP: dev->type mangled!\n");
			kfree_skb(skb, FREE_READ);
			return 0;
	}

	hlen  = dev->addr_len;
	htype = dev->type;
	/* 从报文中提取sip(源地址), tip(目的地址) */
	sha=arp_ptr;
	arp_ptr+=hlen;
	memcpy(&sip,arp_ptr,4);
	arp_ptr+=4;
	tha=arp_ptr;
	arp_ptr+=hlen;
	memcpy(&tip,arp_ptr,4);
  
	/* 
	 *	如果为环回地址，则不处理
	 */
	if(tip == INADDR_LOOPBACK)
	{
		kfree_skb(skb, FREE_READ);
		return 0;
	}

/*
 *  Process entry.  The idea here is we want to send a reply if it is a
 *  request for us or if it is a request for someone else that we hold
 *  a proxy for.  We want to add an entry to our cache if it is a reply
 *  to us or if it is a request for our address.  
 *  (The assumption for this last is that if someone is requesting our 
 *  address, they are probably intending to talk to us, so it saves time 
 *  if we cache their address.  Their address is also probably not in 
 *  our cache, since ours is not in their cache.)
 * 
 *  Putting this another way, we only care about replies if they are to
 *  us, in which case we add them to the cache.  For requests, we care
 *  about those for us and those for our proxies.  We reply to both,
 *  and in the case of requests for us we add the requester to the arp 
 *  cache.
 */
	/* 检查地址是否为本地接口地址/环回地址/广播地址/多播IP地址
	 * 对于广播报文，tip为目的IP地址，MAC=0xff-ff-ff
	 */
	addr_hint = ip_chk_addr(tip);
	
	if(arp->ar_op == htons(ARPOP_REPLY))
	{
		/* 如果为arp响应报文，且目的地址不是本机，则不处理 */
		if(addr_hint!=IS_MYADDR)
		{
			kfree_skb(skb, FREE_READ);
			return 0;
		}
	}
	else
	{ 
		/* 
		 * 请求报文：
		 * 1. 发送给本机
		 * 2. 发送给由本机代理的主机
		 */
		if(tip!=dev->pa_addr)
		{
		/* 目的地址为由本机代理的主机 */
			cli();
		/* 遍历arp缓存表中代理表项(固定为最后一个索引元素指向) */
			for(proxy_entry=arp_tables[PROXY_HASH];
			    proxy_entry;
			    proxy_entry = proxy_entry->next)
			{
			  /* ip地址、网络设备、硬件地址类型同时进行精确匹配 
			   * (proxy_entry->ip^tip)&proxy_entry->mask == 0,则匹配
			   */
			  if (proxy_entry->dev != dev && proxy_entry->htype == htype &&
			      !((proxy_entry->ip^tip)&proxy_entry->mask))
			    break;

			}
			if (proxy_entry)
			{
				/* 找到代理表项符合arp报文地址 */
				memcpy(ha, proxy_entry->ha, hlen);
				sti();
				/* 根据表项中硬件地址响应arp报文；
				 * 该地址为代理主机对应网段网络设备的硬件地址 
				 */
				arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,ha);
				kfree_skb(skb, FREE_READ);
				return 0;
			}
			else
			{
				sti();
				kfree_skb(skb, FREE_READ);
				return 0;
			}
		}
		else
		{
			/* 发往本机的直接做应答；应答后并为结束，还要刷新arp table */
			arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr);
		}
	}
	
	/* 能走到这有两种情况
	 * 1. arp->ar_op == htons(ARPOP_REPLY)，且目标为本机
	 * 2. arp->ar_op == htons(ARPOP_REQUEST)，且目标为本机
	 */
	/* 由于arp table为链式hash表；
	 * 1. 先由source ip地址算出hash值，找到对应的hash bulk 
	 * 2. 在遍历该hash bulk中entry
	 */
	hash = HASH(sip);
	cli();
	for(entry=arp_tables[hash];entry;entry=entry->next)
		if(entry->ip==sip && entry->htype==htype)
			break;

	if(entry)
	{
		memcpy(entry->ha, sha, hlen);/* 刷新对应的硬件地址 */
		entry->hlen = hlen;
		entry->last_used = jiffies;
		if (!(entry->flags & ATF_COM))
		{
			/* 是未完成表项，删除定时器，标志为完成状态 */
			del_timer(&entry->timer);
			entry->flags |= ATF_COM;
			sti();
		/* 滞留的数据包重发：
		 * 1. arp请求的主动发起是在发送普通数据包时无法建立链路层首部的情况下进行的(不知道对端硬件地址)
		 * 2. 内核在进行arp地址解析过程中，会将这个数据包暂存在新建的arp表项的相关队列中
		 * 3. 等到新创建的表项完成所有字段的初始化(硬件地址)，才把滞留的数据包发送出去(arp_send_q)
		 */
			arp_send_q(entry, sha);
		}
		else
		{
			sti();//是已经完成的表项，那么数据包自然已经发送出去了，不作处理  
		}
	}
	else
	{
	/* 没有找到，则需要创建一个新的表项插入; hash bulk 首部插入 */
		entry = (struct arp_table *)kmalloc(sizeof(struct arp_table),GFP_ATOMIC);
		if(entry == NULL)
		{
			sti();
			printk("ARP: no memory for new arp entry\n");

			kfree_skb(skb, FREE_READ);
			return 0;
		}

		entry->mask = DEF_ARP_NETMASK;
		entry->ip = sip;
		entry->hlen = hlen;
		entry->htype = htype;
		entry->flags = ATF_COM;
		init_timer(&entry->timer);
		memcpy(entry->ha, sha, hlen);
		entry->last_used = jiffies;
		entry->dev = skb->dev;
		skb_queue_head_init(&entry->skb);
		entry->next = arp_tables[hash];
		arp_tables[hash] = entry;
		sti();
	}

	/* arp报文功成身就，寿终正寝 */
	kfree_skb(skb, FREE_READ);
	return 0;
}

```

#### arp_send

``` c++
void arp_send(int type, int ptype, unsigned long dest_ip, 
	      struct device *dev, unsigned long src_ip, 
	      unsigned char *dest_hw, unsigned char *src_hw)
{
	struct sk_buff *skb;
	struct arphdr *arp;
	unsigned char *arp_ptr;

	/*
	 *	No arp on this interface.
	 */
	
	if(dev->flags&IFF_NOARP)//非ARP协议
		return;

	/*
	 *	大小：以太网帧头+arp报头+源端、目的端对应MAC,IP
	 */
	skb = alloc_skb(sizeof(struct arphdr)+ 2*(dev->addr_len+4)
				+ dev->hard_header_len, GFP_ATOMIC);
	if (skb == NULL)
	{
		printk("ARP: no memory to send an arp packet\n");
		return;
	}
	skb->len = sizeof(struct arphdr) + dev->hard_header_len + 2*(dev->addr_len+4);
	skb->arp = 1;  //表示已完成MAC首部的创建  
	skb->dev = dev;//绑定设备  
	skb->free = 1; //数据包发送后立即释放  

	/* Fill the device header for the ARP frame
	 * 如果dest_hw==NULL,则用广播地址填入
	 * 如果src_hw==NULL,则用NULL填入
	 */
	dev->hard_header(skb->data,dev,ptype,dest_hw?dest_hw:dev->broadcast,src_hw?src_hw:NULL,skb->len,skb);

	/* 得到arp报头。arp报文内存布局:以太网帧头 | arp报头 | 地址类   */
	arp = (struct arphdr *) (skb->data + dev->hard_header_len);
	arp->ar_hrd = htons(dev->type);/* 设置arp报文头中硬件类型 */
#ifdef CONFIG_AX25
	arp->ar_pro = (dev->type != ARPHRD_AX25)? htons(ETH_P_IP) : htons(AX25_P_IP);
#else
	arp->ar_pro = htons(ETH_P_IP);
#endif
	arp->ar_hln = dev->addr_len;
	arp->ar_pln = 4;
	arp->ar_op = htons(type);/* 设置arp报文头中报文类型 */

	arp_ptr=(unsigned char *)(arp+1);/* arp指向apr报文数据部分 */
	/* 拷入数据部分MAC,IP地址 */
	memcpy(arp_ptr, src_hw, dev->addr_len);
	arp_ptr+=dev->addr_len;
	memcpy(arp_ptr, &src_ip,4);
	arp_ptr+=4;
	if (dest_hw != NULL)
		memcpy(arp_ptr, dest_hw, dev->addr_len);
	else
		memset(arp_ptr, 0, dev->addr_len);
	arp_ptr+=dev->addr_len;
	memcpy(arp_ptr, &dest_ip, 4);
	/* 将该数据包传递给驱动程序，由驱动程序最终将数据发送到物理介质上 
	 * 1. dev_queue_xmit完成其本层处理后，调用发送设备device结构之hard_start_xmit指针指向的不同设备具体硬件发送函数
	 * 2. skb_queue_tail： 每个device中默认有DEV_NUMBUFFS个数据包发送环形双向队列；待发送数据包根据不同的优先级加入不同队列的尾部
	 * 3. skb_dequeue：从环形队列头部取出一个包发送；在真正将报文发到硬件前；会遍历 packet_type 全局队列，将报文发到所有对本类型报文感兴趣的钩子上
	 */
	dev_queue_xmit(skb, dev, 0);
}
```

####

``` c++
```

#### arp_find

``` c++
/*
 * 在elp_start_xmit(hard_start_xmit)->rebuild_header函数中被用来重建以太报文头部
 * 根据目的IP地址在ARP缓存中查找匹配的表项从而完成数据帧中链路层首部的创建工作
 * 
 */
int arp_find(unsigned char *haddr, unsigned long paddr, struct device *dev,
	   unsigned long saddr, struct sk_buff *skb)
{
	struct arp_table *entry;
	unsigned long hash;
#ifdef CONFIG_IP_MULTICAST
	unsigned long taddr;
#endif	
	/*
	 * 根据tip判断是什么类型的IP地址
	 * 1. 本机地址
	 * 2. 多播地址
	 * 3. 广播地址
	 */
	switch (ip_chk_addr(paddr))
	{
		case IS_MYADDR:
			printk("ARP: arp called for own IP address\n");
			memcpy(haddr, dev->dev_addr, dev->addr_len);
			skb->arp = 1;
			return 0;
#ifdef CONFIG_IP_MULTICAST
		case IS_MULTICAST:
			if(dev->type==ARPHRD_ETHER || dev->type==ARPHRD_IEEE802)
			{
				haddr[0]=0x01;
				haddr[1]=0x00;
				haddr[2]=0x5e;
				taddr=ntohl(paddr);
				haddr[5]=taddr&0xff;
				taddr=taddr>>8;
				haddr[4]=taddr&0xff;
				taddr=taddr>>8;
				haddr[3]=taddr&0x7f;
				return 0;
			}
		/*
		 *	If a device does not support multicast broadcast the stuff (eg AX.25 for now)
		 */
#endif
		
		case IS_BROADCAST:
			memcpy(haddr, dev->broadcast, dev->addr_len);
			skb->arp = 1;
			return 0;
	}

	hash = HASH(paddr);//找到tid所属hash bulk
	cli();

	/* 从arp table中找到具体表项 */
	entry = arp_lookup(paddr, PROXY_NONE);

	if (entry != NULL) 	/* It exists */
	{
		if (!(entry->flags & ATF_COM))
		{
			/*
			 *	A request was already send, but no reply yet. Thus
			 *	queue the packet with the previous attempt
			 */
			
			if (skb != NULL)
			{
				skb_queue_tail(&entry->skb, skb);
				skb_device_unlock(skb);
			}
			sti();
			return 1;
		}

		/* 更新匹配表项的最近一次使用时间 */
		entry->last_used = jiffies;
		/* 将表项中mac返回给上层使用 */
		memcpy(haddr, entry->ha, dev->addr_len);
		if (skb)
			skb->arp = 1;
		sti();
		return 0;
	}

	/* 如果没有找到对应的表项，说明目前arp table不存在该ip的mac信息，需要新获取. */
	entry = (struct arp_table *) kmalloc(sizeof(struct arp_table),
					GFP_ATOMIC);
	if (entry != NULL)
	{
	/* 初始化arp表项. */
	        entry->mask = DEF_ARP_NETMASK;
		entry->ip = paddr;
		entry->hlen = dev->addr_len;
		entry->htype = dev->type;
		entry->flags = 0;
		memset(entry->ha, 0, dev->addr_len);
		entry->dev = dev;
		entry->last_used = jiffies;
		init_timer(&entry->timer);
		/* 注册定时器任务，该函数会给目标地址发arp报文，三次没响应则删除entry. */
		entry->timer.function = arp_expire_request;
		entry->timer.data = (unsigned long)entry;
		entry->timer.expires = ARP_RES_TIME;
		entry->next = arp_tables[hash];/* 将新entry加入到hash bulk首部. */
		arp_tables[hash] = entry;
		add_timer(&entry->timer);
		entry->retries = ARP_MAX_TRIES;
		skb_queue_head_init(&entry->skb);/* 组装一个arp请求报文. */
		if (skb != NULL)
		{	//待发送数据包的缓存工作  
			skb_queue_tail(&entry->skb, skb);
			skb_device_unlock(skb);
		}
	}
	else
	{
		if (skb != NULL && skb->free)
			kfree_skb(skb, FREE_WRITE);
  	}
	sti();

	/* 对于没有找到arp表项，组装完entry后，发送arp request. */
	arp_send(ARPOP_REQUEST, ETH_P_ARP, paddr, dev, saddr, NULL, 
		 dev->dev_addr);

	return 1;
}
```

####

``` c++
```

####

``` c++
```

## 总结

### linux网络栈初始化

1. start_kernel->sock_init->proto_init

* proto_init: 初始化目前linux支持的协议族，目前支持UNIX、802.2、SNAP、AX.25、INET、IPX、DDP；

* inet_proto_init：初始化INET协议族，将INET协议族的操作函数注册到全局协议族数组 pops(BSD层到inet_sock层接口) 中；该协议族包含 inet_create,inet_bind,inet_connect,inet_socketpair...属于会话层接口函数

	1. proto: inet_sock 层到传输层 操作的统一接口,主要用于操作sock结构
	
	2. 初始化INET协议族中的传输层协议，目前包括TCP、UDP、Raw
* 

## 附录

softnet_data: 内核为每个CPU分配一个softnet_data数据空间，每个CPU都有一个这样的队列，用于接受数据包

sk_buff：描述帧结构属性，持有socket，到底时间，到达设备，各层头部大小，下一站路由入口，帧长度，校验和等

sk_buff_head：数据包队列结构

net_device: 描述一个网络设备的所有属性，数据等信息

inet_protosw：向IP层注册socket层调用操作接口

#### packet_type

``` c++
/* 数据包类型，kernel有个全局链表，保存所有需要接受的数据包. */
struct packet_type {
  unsigned short	type;	/* This is really htons(ether_type). */
  struct device *	dev;
  /* func为收到对应数据包的回调函数 */
  int			(*func) (struct sk_buff *, struct device *,
				 struct packet_type *);
  void			*data;
  struct packet_type	*next;
}
```

#### arp_table

``` c++
/* ARP缓存中的每一个由arp_table结构表示，将这些表项串联起来构成链表，就构成了ARP缓存 */
struct arp_table
{
	struct arp_table		*next;			/* Linked entry list 		*/
	unsigned long			last_used;		/* For expiry 			*/
	unsigned int			flags;			/* ATF_PERM 永不过期 		*/
	unsigned long			ip;			/* ip address of entry 		*/
	unsigned long			mask;			/* netmask - used for generalised proxy arps (tridge) 		*/
	unsigned char			ha[MAX_ADDR_LEN];	/* Hardware address		*/
	unsigned char			hlen;			/* Length of hardware address 	*/
	unsigned short			htype;			/* Type of hardware in use	*/
	struct device			*dev;			/* Device the entry is tied to 	*/

	/*
	 *	The following entries are only used for unresolved hw addresses.
	 */
	
	struct timer_list		timer;			/* expire timer 		*/
	int				retries;		/* remaining retries	 	*/
	struct sk_buff_head		skb;			/* list of queued packets 	*/
};
```

## 参考资料

[电子版下载](https://download.csdn.net/download/feihu02/9565549)

[OSI七层模型](https://blog.csdn.net/sinat_32176267/article/details/78191035)

[内核通知链](https://www.cnblogs.com/mosp/p/3551006.html)

[linux内核协议栈详解](https://blog.csdn.net/armlinuxww/article/details/99542306)


