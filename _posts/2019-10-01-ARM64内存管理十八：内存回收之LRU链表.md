---
title: ARM64内存管理十八：内存回收之LRU链表
date: 2019-09-30
categories:
- linux-memory
tags:
- mempool
---

## 前沿

### 往篇回顾

>在上一篇中，主要分析了内存池的实现、运行机制；内存池实际是一个最后的内存资源储存池，本身还是依赖于现有的伙伴系统或者slub系统

* 主要涉及`mempool_create`, `mempool_destroy`, `mempool_alloc`, `mempool_free`这几个函数；

* 重点在内存申请的时候，首先从自定义的mempool->alloc尝试分配，失败后再从内存池中获取；

* 如果内存池也分配失败，则会自行加入mempool->wait队列中，并将本进程自动睡眠等待有空闲内存或者时间截止被唤醒；


### 内存回收简述

* 当linux系统内存压力就大时，就会对系统的每个压力大的zone(最新的linux动向逐渐转向按node回收)进程内存回收，内存回收主要是针对匿名页和文件页进行的

* 内存回收主要有两个方面: 释放页；将页回写到swap区，再释放内存页

   1. 进程堆栈，数据段使用的匿名页：存放swap区
   
   2. 进程代码段映射的可执行文件的文件页：直接释放
   
   3. 打开文件进行读写使用的文件页：如果页中数据与文件数据不一致，则回写到磁盘对应的文件页，如果一致则释放
   
   4. 进行文件映射mmap共享内存时使用的页：如果页中数据与文件数据不一致，则进行回写到磁盘对应文件中，如果一致，则直接释放

   5. 进行匿名mmap共享内存时使用的页：存放到swap分区中

   6. 进行shmem共享内存时使用的页：存放到swap分区中


### lru链表分类

* LRU_INACTIVE_ANON：称为非活动匿名页lru链表，此链表中保存的是此zone中所有最近没被访问过的并且可以存放到swap分区的页描述符，在此链表中的页描述符的PG_active标志为0

* LRU_ACTIVE_ANON：称为活动匿名页lru链表，此链表中保存的是此zone中所有最近被访问过的并且可以存放到swap分区的页描述符，此链表中的页描述符的PG_active标志为1

* LRU_INACTIVE_FILE：称为非活动文件页lru链表，此链表中保存的是此zone中所有最近没被访问过的文件页的页描述符，此链表中的页描述符的PG_active标志为0

* LRU_ACTIVE_FILE：称为活动文件页lru链表，此链表中保存的是此zone中所有最近被访问过的文件页的页描述符，此链表中的页描述符的PG_active标志为1

* LRU_UNEVICTABLE：此链表中保存的是此zone中所有禁止换出的页的描述符, 一般是被mlock锁定

### lru缓存

* 在多核环境下，在同时需要对lru链表进行修改时，锁的竞争会非常频繁，因此内核提供了一个[lru缓存](#pagevec)机制，用以减少锁的竞争频率

* lru缓存是按照要对lru操作的类型纬度定义的，对lru链表的操作主要有以下几种：

    1. 将不处于lru链表的新页放入到lru链表中, 对应`static  DEFINE_PER_CPU(struct pagevec, lru_add_pvec)`
    
    2. 将非活动lru链表中的页移动到非活动lru链表尾部(活动页不需要这样做，后面说明), 对应`static DEFINE_PER_CPU(struct pagevec, lru_rotate_pvecs)`
    
    3. 将处于活动lru链表尾部的页移动到非活动lru链表, 对应`static DEFINE_PER_CPU(struct pagevec, lru_deactivate_pvecs)`
    
    4. 将处于非活动lru链表的页移动到活动lru链表头, 对应`static DEFINE_PER_CPU(struct pagevec, activate_page_pvecs)`
    
    5. 将页从lru链表中移除(不需要依赖lru)

* 由于4中lru缓冲链表都是cpu级别的；而目前lru的5种链表都是zone级别的，因此在一个页加入lru缓存前，必须设置好页的属性，才能配合lru缓存进行工作

### 本篇主要内容

>对于整个内存回收来说，lru链表是关键中的关键，实际上整个内存回收，做的事情就是处理LRU(Least Recently Used)链表的收缩，所以这篇文章就先说说系统的lru链表
